                "array": "The {attribute} field must have {value} items or more.",
                "file": "The {attribute} field must be greater than or equal to {value} kilobytes.",
                "numeric": "The {attribute} field must be greater than or equal to {value}.",
                "string": "The {attribute} field must be greater than or equal to {value} characters."
            },
            "hex_color": "The {attribute} field must be a valid hexadecimal color.",
            "image": "The {attribute} field must be an image.",
            "in": "The selected {attribute} is invalid.",
            "in_array": "The {attribute} field must exist in {other}.",
            "integer": "The {attribute} field must be an integer.",
            "ip": "The {attribute} field must be a valid IP address.",
            "ipv4": "The {attribute} field must be a valid IPv4 address.",
            "ipv6": "The {attribute} field must be a valid IPv6 address.",
            "json": "The {attribute} field must be a valid JSON string.",
            "list": "The {attribute} field must be a list.",
            "lowercase": "The {attribute} field must be lowercase.",
            "lt": {
                "array": "The {attribute} field must have less than {value} items.",
                "file": "The {attribute} field must be less than {value} kilobytes.",
                "numeric": "The {attribute} field must be less than {value}.",
                "string": "The {attribute} field must be less than {value} characters."
            },
            "lte": {
                "array": "The {attribute} field must not have more than {value} items.",
                "file": "The {attribute} field must be less than or equal to {value} kilobytes.",
                "numeric": "The {attribute} field must be less than or equal to {value}.",
                "string": "The {attribute} field must be less than or equal to {value} characters."
            },
            "mac_address": "The {attribute} field must be a valid MAC address.",
            "max": {
                "array": "The {attribute} field must not have more than {max} items.",
                "file": "The {attribute} field must not be greater than {max} kilobytes.",
                "numeric": "The {attribute} field must not be greater than {max}.",
                "string": "The {attribute} field must not be greater than {max} characters."
            },
            "max_digits": "The {attribute} field must not have more than {max} digits.",
            "mimes": "The {attribute} field must be a file of type: {values}.",
            "mimetypes": "The {attribute} field must be a file of type: {values}.",
            "min": {
                "array": "The {attribute} field must have at least {min} items.",
                "file": "The {attribute} field must be at least {min} kilobytes.",
                "numeric": "The {attribute} field must be at least {min}.",
                "string": "The {attribute} field must be at least {min} characters."
            },
            "min_digits": "The {attribute} field must have at least {min} digits.",
            "missing": "The {attribute} field must be missing.",
            "missing_if": "The {attribute} field must be missing when {other} is {value}.",
            "missing_unless": "The {attribute} field must be missing unless {other} is {value}.",
            "missing_with": "The {attribute} field must be missing when {values} is present.",
            "missing_with_all": "The {attribute} field must be missing when {values} are present.",
            "multiple_of": "The {attribute} field must be a multiple of {value}.",
            "not_in": "The selected {attribute} is invalid.",
            "not_regex": "The {attribute} field format is invalid.",
            "numeric": "The {attribute} field must be a number.",
            "password": {
                "letters": "The {attribute} field must contain at least one letter.",
                "mixed": "The {attribute} field must contain at least one uppercase and one lowercase letter.",
                "numbers": "The {attribute} field must contain at least one number.",
                "symbols": "The {attribute} field must contain at least one symbol.",
                "uncompromised": "The given {attribute} has appeared in a data leak. Please choose a different {attribute}."
            },
            "present": "The {attribute} field must be present.",
            "present_if": "The {attribute} field must be present when {other} is {value}.",
            "present_unless": "The {attribute} field must be present unless {other} is {value}.",
            "present_with": "The {attribute} field must be present when {values} is present.",
            "present_with_all": "The {attribute} field must be present when {values} are present.",
            "prohibited": "The {attribute} field is prohibited.",
            "prohibited_if": "The {attribute} field is prohibited when {other} is {value}.",
            "prohibited_unless": "The {attribute} field is prohibited unless {other} is in {values}.",
            "prohibits": "The {attribute} field prohibits {other} from being present.",
            "regex": "The {attribute} field format is invalid.",
            "required": "The {attribute} field is required.",
            "required_array_keys": "The {attribute} field must contain entries for: {values}.",
            "required_if": "The {attribute} field is required when {other} is {value}.",
            "required_if_accepted": "The {attribute} field is required when {other} is accepted.",
            "required_if_declined": "The {attribute} field is required when {other} is declined.",
            "required_unless": "The {attribute} field is required unless {other} is in {values}.",
            "required_with": "The {attribute} field is required when {values} is present.",
            "required_with_all": "The {attribute} field is required when {values} are present.",
            "required_without": "The {attribute} field is required when {values} is not present.",
            "required_without_all": "The {attribute} field is required when none of {values} are present.",
            "same": "The {attribute} field must match {other}.",
            "size": {
                "array": "The {attribute} field must contain {size} items.",
                "file": "The {attribute} field must be {size} kilobytes.",
                "numeric": "The {attribute} field must be {size}.",
                "string": "The {attribute} field must be {size} characters."
            },
            "starts_with": "The {attribute} field must start with one of the following: {values}.",
            "string": "The {attribute} field must be a string.",
            "timezone": "The {attribute} field must be a valid timezone.",
            "unique": "The {attribute} has already been taken.",
            "uploaded": "The {attribute} failed to upload.",
            "uppercase": "The {attribute} field must be uppercase.",
            "url": "The {attribute} field must be a valid URL.",
            "ulid": "The {attribute} field must be a valid ULID.",
            "uuid": "The {attribute} field must be a valid UUID.",
            "custom": {
                "attribute-name": {
                    "rule-name": "custom-message"
                }
            },
            "attributes": []
        }
    }
}


================================================
File: resources/js/Components/AddressLink.vue
================================================
<script setup>
	import { useAddress } from "@/hooks/explorers";

	const props = defineProps({
		address: String,
		chainId: [String, Number],
		len: { type: Number, default: 16 },
	});
	const [shortAddress, etherScanLink] = useAddress(
		props.address,
		props.chainId,
		props.len,
	);
</script>
<template>
	<slot :shortAddress="shortAddress" :etherScanLink="etherScanLink">
		<a
			:href="etherScanLink"
			target="_blank"
			class="cursor-pointer select-none font-semibold hover:text-primary">
			{{ shortAddress }}
		</a>
	</slot>
</template>


================================================
File: resources/js/Components/ApplicationLogo.vue
================================================
<script setup>
	import { Link } from "@inertiajs/vue3";
</script>
<template>
	<Link href="/">
		<img
			v-if="$page.props.appLogo"
			:src="$page.props.appLogo"
			v-bind="$attrs"
			alt="Windster Logo" />
		<h1 v-else v-bind="$attrs" class="text-3xl text-primary">
			{{ $page.props.appName }}
		</h1>
	</Link>
</template>


================================================
File: resources/js/Components/ApproveTokenButton.vue
================================================
<script setup>
	import { computed, ref, watch } from "vue";

	import { getPublicClient } from "@wagmi/core";
	import { useAccount, useConfig } from "@wagmi/vue";
	import { erc20Abi, isAddress, zeroAddress } from "viem";

	import BaseButton from "@/Components/BaseButton.vue";
	import CollapseTransition from "@/Components/CollapseTransition.vue";
	import Loading from "@/Components/Loading.vue";
	import TxStatus from "@/Components/TxStatus.vue";
	import { useReactiveContractCall } from "@/hooks/useContractCall";
	const props = defineProps({
		contract: { type: String, required: true },
		spender: { type: String, required: true },
		amount: { type: BigInt, default: 0n },
		shouldApprove: { type: Boolean, default: true },
	});
	const emit = defineEmits(["approve"]);
	const { address } = useAccount();
	const publicClient = getPublicClient(useConfig());
	const allowance = ref(0);
	const loading = ref(false);
	const approved = (reciept) => emit("approve", reciept);
	const update = async () => {
		loading.value = true;
		allowance.value = await publicClient.readContract({
			address: props.contract,
			abi: erc20Abi,
			functionName: "allowance",
			args: [address.value, props.spender],
		});
		loading.value = false;
	};
	const contractAddress = computed(() => props.contract);
	const state = useReactiveContractCall(erc20Abi, contractAddress);
	state.status = "Approve tokens to deposit";
	const approve = async () => {
		await state.call("approve", [props.spender, props.amount]);
		await update();
		approved(state.receipt);
	};

	const requiresApproval = computed(
		() =>
			props.contract !== zeroAddress &&
			props.shouldApprove &&
			allowance.value < props.amount,
	);
	watch(
		[() => props.shouldApprove, () => props.contract, () => props.spender],
		([shouldApprove, contract, spender, amount]) => {
			if (
				!shouldApprove ||
				!isAddress(contract) ||
				!isAddress(spender) ||
				contract === zeroAddress
			)
				return;

			update();
		},
		{ immediate: true },
	);
</script>
<template>
	<CollapseTransition>
		<div
			class="relative mt-6 flex gap-3"
			v-bind="$attrs"
			v-show="requiresApproval">
			<slot name="approval" :state="state" :approve="approve">
				<TxStatus v-if="state.called === 'approve'" :state="state" />
				<BaseButton
					:disabled="state.busy || state.confirming"
					class="w-full"
					outlined
					@click.prevent="approve">
					<slot name="button">
						<Loading
							v-if="state.busy || state.confirming"
							class="-ml-1 !mr-2 inline-flex" />
						{{ $t("Approve Tokens") }}
					</slot>
				</BaseButton>
			</slot>
		</div>
	</CollapseTransition>
	<CollapseTransition>
		<div v-bind="$attrs" v-show="!requiresApproval">
			<slot />
		</div>
	</CollapseTransition>
</template>


================================================
File: resources/js/Components/Banner.vue
================================================
<script setup>
	import { ref, watchEffect } from "vue";

	import { usePage } from "@inertiajs/vue3";

	const page = usePage();
	const show = ref(true);
	const style = ref("success");
	const message = ref("");

	watchEffect(async () => {
		style.value = page.props.flash?.bannerStyle || "success";
		message.value = page.props.flash?.banner || "";
		show.value = true;
	});
</script>

<template>
	<div>
		<div
			v-if="show && message"
			:class="{
				'bg-emerald-500': style == 'success',
				'bg-red-700': style == 'error',
				'bg-sky-700': style == 'info',
			}">
			<div class="max-w-screen-xl mx-auto py-2 px-3 sm:px-6 lg:px-8">
				<div class="flex items-center justify-between flex-wrap">
					<div class="w-0 flex-1 flex items-center min-w-0">
						<span
							class="flex p-2 rounded-lg"
							:class="{
								'bg-emerald-600': style == 'success',
								'bg-red-600': style == 'error',
								'bg-sky-600': style == 'info',
							}">
							<svg
								v-if="style == 'success' || style == 'info'"
								class="h-5 w-5 text-white"
								xmlns="http://www.w3.org/2000/svg"
								fill="none"
								viewBox="0 0 24 24"
								stroke-width="1.5"
								stroke="currentColor">
								<path
									stroke-linecap="round"
									stroke-linejoin="round"
									d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
							</svg>

							<svg
								v-if="style == 'error'"
								class="h-5 w-5 text-white"
								xmlns="http://www.w3.org/2000/svg"
								fill="none"
								viewBox="0 0 24 24"
								stroke-width="1.5"
								stroke="currentColor">
								<path
									stroke-linecap="round"
									stroke-linejoin="round"
									d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" />
							</svg>
						</span>

						<p class="ms-3 font-medium text-sm text-white truncate">
							{{ message }}
						</p>
					</div>

					<div class="shrink-0 sm:ms-3">
						<button
							type="button"
							class="-me-1 flex p-2 rounded-md focus:outline-none sm:-me-2 transition"
							:class="{
								'hover:bg-emerald-600 focus:bg-emerald-600':
									style == 'success',
								'hover:bg-red-600 focus:bg-red-600':
									style == 'error',
								'hover:bg-sky-600 focus:bg-sky-600':
									style == 'info',
							}"
							aria-label="Dismiss"
							@click.prevent="show = false">
							<svg
								class="h-5 w-5 text-white"
								xmlns="http://www.w3.org/2000/svg"
								fill="none"
								viewBox="0 0 24 24"
								stroke-width="1.5"
								stroke="currentColor">
								<path
									stroke-linecap="round"
									stroke-linejoin="round"
									d="M6 18L18 6M6 6l12 12" />
							</svg>
						</button>
					</div>
				</div>
			</div>
		</div>
	</div>
</template>


================================================
File: resources/js/Components/BaseButton.vue
================================================
<script setup>
	import { computed } from "vue";

	import { Link } from "@inertiajs/vue3";

	const props = defineProps({
		// Button type props
		primary: {
			type: Boolean,
			default: true,
		},
		secondary: {
			type: Boolean,
			default: false,
		},
		danger: {
			type: Boolean,
			default: false,
		},
		// Common props
		outlined: {
			type: Boolean,
			default: false,
		},
		link: {
			type: Boolean,
			default: false,
		},
		url: {
			type: Boolean,
			default: false,
		},
		size: {
			type: String,
			default: "sm",
			validator: (value) =>
				["xss", "xs", "sm", "md", "lg", "xl"].includes(value),
		},
		iconMode: {
			type: Boolean,
			default: false,
		},
	});

	const sizeClasses = computed(() => ({
		xss: props.iconMode ? "w-5 h-5 text-xs" : "px-1.5 py-0.5 text-xs",
		xs: props.iconMode
			? "w-6 h-6 text-xs"
			: "px-2.5 py-1.5 font-semibold text-xs",
		sm: props.iconMode ? "w-8 h-8 text-sm" : "px-3 py-2 text-sm",
		md: props.iconMode ? "w-10 h-10 text-base" : "px-4 py-2.5 text-base",
		lg: props.iconMode ? "w-12 h-12 text-lg" : "px-5 py-3 text-lg",
		xl: props.iconMode ? "w-14 h-14 text-xl" : "px-6 py-3.5 text-xl",
	}));

	const comp = computed(() =>
		props.link ? Link : props.url ? "a" : "button",
	);

	const colorClasses = computed(() => {
		if (props.danger) {
			return props.outlined
				? "bg-transparent border-red-400 text-red-400 hover:bg-red-600 hover:text-white focus:ring-red-500"
				: "bg-red-600 text-white  border-transparent hover:bg-red-500 active:bg-red-700 focus:ring-red-500";
		}

		if (props.secondary) {
			return props.outlined
				? "bg-transparent  border-gray-600 text-gray-300 hover:bg-gray-750 hover:text-white focus:ring-gray-400"
				: "bg-gray-700 text-gray-200 hover:text-white border-transparent hover:bg-gray-600 active:bg-gray-750 focus:ring-gray-400";
		}

		// Primary (default)
		return props.outlined
			? "bg-transparent  border-primary text-primary hover:bg-primary hover:text-black focus:ring-primary"
			: "bg-primary text-black  border-transparent hover:bg-primary-dark focus:ring-primary";
	});
</script>

<template>
	<component
		:is="comp"
		:class="[
			'inline-flex items-center justify-center font-medium transition-colors duration-200',
			'focus:outline-none focus:ring-2 focus:ring-offset-2',
			sizeClasses[size],
			iconMode ? 'aspect-square p-0' : '',
			colorClasses,
			['xss', 'xs'].includes(size) ? 'border' : 'border-2',
			'rounded cursor-pointer disabled:pointer-events-none disabled:opacity-70 ring-offset-gray-900',
		]"
		v-bind="$attrs">
		<slot></slot>
	</component>
</template>


================================================
File: resources/js/Components/ChainInfo.vue
================================================
<script setup>
	import { computed } from "vue";

	import { NetworkIcon } from "@/Icons";
	import { networks } from "@/lib/wagmi";

	const props = defineProps({
		chainId: Number,
	});

	const chain = computed(() =>
		networks.find((c) => c.id === parseInt(props.chainId)),
	);
</script>
<template>
	<div v-if="chainId" class="flex flex-row align-middle items-center">
		<NetworkIcon
			class="w-5 h-5 rounded-full inline-table mr-3"
			:chain-id="chainId" />
		<span class="text-emerald-600 dark:text-emerald-400 font-bold text-xs">
			<slot>{{ chain?.name }}</slot>
		</span>
	</div>
</template>


================================================
File: resources/js/Components/ChainSymbol.vue
================================================
<script setup>
	import { computed } from "vue";

	import { networks } from "@/lib/wagmi";

	const props = defineProps({
		chainId: Number,
	});

	const chain = computed(() =>
		networks.find((c) => c.id === parseInt(props.chainId)),
	);
</script>
<template>
	<slot v-if="chainId && chain" :symbol="chain?.nativeCurrency.symbol">
		<span v-bind="$attrs">
			{{ chain?.nativeCurrency.symbol }}
		</span>
	</slot>
</template>


================================================
File: resources/js/Components/Checkbox.vue
================================================
<script setup>
import { computed } from 'vue';
