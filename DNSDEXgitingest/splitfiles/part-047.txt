
			<!-- Placeholder -->
			<template v-if="placeholder && !hasSelected && !search">
				<slot name="placeholder">
					<div :class="classList.placeholder" aria-hidden="true">
						{{ placeholder }}
					</div>
				</slot>
			</template>

			<!-- Spinner -->
			<slot v-if="loading || resolving" name="spinner">
				<span :class="classList.spinner" aria-hidden="true"></span>
			</slot>

			<!-- Clear -->
			<slot
				v-if="hasSelected && !disabled && canClear && !busy"
				name="clear"
				:clear="clear"
				:classList="classList">
				<span
					aria-hidden="true"
					tabindex="0"
					role="button"
					data-clear
					aria-roledescription="❎"
					:class="classList.clear"
					@click="clear"
					@keyup.enter="clear">
					<span :class="classList.clearIcon"></span>
				</span>
			</slot>

			<!-- Caret -->
			<slot
				:isOpen="isOpen"
				:handleCaretClick="handleCaretClick"
				v-if="caret && showOptions"
				name="caret">
				<span
					:class="classList.caret"
					@click="handleCaretClick"
					aria-hidden="true"></span>
			</slot>
		</div>

		<!-- Options -->
		<div :class="classList.dropdown" tabindex="-1">
			<slot
				name="beforelist"
				:options="fo"
				:search="search"
				:clearSearch="clearSearch"
				:handleSearchInpu="handleSearchInput"
				:handleKeypress="handleKeypress"
				:handlePaste="handlePaste"></slot>
			<ul :class="classList.options" :id="ariaControls" role="listbox">
				<template v-if="groups">
					<li
						v-for="(group, i, key) in fg"
						:class="classList.group"
						:key="key"
						:id="ariaGroupId(group)"
						:aria-label="
							ariaGroupLabel(localize(group[groupLabel]))
						"
						:aria-selected="isSelected(group)"
						role="option">
						<div
							v-if="!group.__CREATE__"
							:class="classList.groupLabel(group)"
							:data-pointed="isPointed(group)"
							@mouseenter="setPointer(group, i)"
							@click="handleGroupClick(group)">
							<slot
								name="grouplabel"
								:group="group"
								:is-selected="isSelected"
								:is-pointed="isPointed">
								<span
									v-html="localize(group[groupLabel])"></span>
							</slot>
						</div>

						<ul
							:class="classList.groupOptions"
							:aria-label="
								ariaGroupLabel(localize(group[groupLabel]))
							"
							role="group">
							<li
								v-for="(option, i, key) in group.__VISIBLE__"
								:class="classList.option(option, group)"
								:data-pointed="isPointed(option)"
								:data-selected="isSelected(option) || undefined"
								:key="key"
								@mouseenter="setPointer(option)"
								@click="handleOptionClick(option)"
								:id="ariaOptionId(option)"
								:aria-selected="isSelected(option)"
								:aria-label="
									ariaOptionLabel(localize(option[label]))
								"
								role="option">
								<slot
									name="option"
									:option="option"
									:is-selected="isSelected"
									:is-pointed="isPointed"
									:search="search">
									<span>{{ localize(option[label]) }}</span>
								</slot>
							</li>
						</ul>
					</li>
				</template>
				<template v-else>
					<li
						v-for="(option, i, key) in fo"
						:class="classList.option(option)"
						:data-pointed="isPointed(option)"
						:data-selected="isSelected(option) || undefined"
						:key="key"
						@mouseenter="setPointer(option)"
						@click="handleOptionClick(option)"
						:id="ariaOptionId(option)"
						:aria-selected="isSelected(option)"
						:aria-label="ariaOptionLabel(localize(option[label]))"
						role="option">
						<slot
							name="option"
							:option="option"
							:isSelected="isSelected"
							:is-pointed="isPointed"
							:search="search">
							<span>{{ localize(option[label]) }}</span>
						</slot>
					</li>
				</template>
			</ul>

			<slot v-if="noOptions" name="nooptions">
				<div
					:class="classList.noOptions"
					v-html="localize(noOptionsText)"></div>
			</slot>

			<slot v-if="noResults" name="noresults">
				<div
					:class="classList.noResults"
					v-html="localize(noResultsText)"></div>
			</slot>

			<div
				v-if="infinite && hasMore"
				:class="classList.inifinite"
				ref="infiniteLoader">
				<slot name="infinite">
					<span :class="classList.inifiniteSpinner"></span>
				</slot>
			</div>

			<slot name="afterlist" :options="fo"></slot>
		</div>

		<!-- Hacky input element to show HTML5 required warning -->
		<input
			v-if="required"
			:class="classList.fakeInput"
			tabindex="-1"
			:value="textValue"
			required />

		<!-- Native input support -->
		<template v-if="nativeSupport">
			<input
				v-if="mode == 'single'"
				type="hidden"
				:name="name"
				:value="plainValue !== undefined ? plainValue : ''" />
			<template v-else>
				<input
					v-for="(v, i) in plainValue"
					type="hidden"
					:name="`${name}[]`"
					:value="v"
					:key="i" />
			</template>
		</template>

		<!-- Screen reader assistive text -->
		<div
			v-if="searchable && hasSelected"
			:class="classList.assist"
			:id="ariaAssist"
			aria-hidden="true">
			{{ ariaLabel }}
		</div>

		<!-- Create height for empty input -->
		<div :class="classList.spacer"></div>
	</div>
</template>


================================================
File: resources/js/Components/Multiselect/composables/useA11y.js
================================================
import { computed, onMounted, ref, toRefs } from 'vue';

export default function useA11y (props, context, dep)
{
  const {
    placeholder, id, valueProp, label: labelProp, mode, aria, searchable ,
  } = toRefs(props);

  // ============ DEPENDENCIES ============

  const pointer = dep.pointer;
  const iv = dep.iv;
  const hasSelected = dep.hasSelected;
  const multipleLabelText = dep.multipleLabelText;

  // ================ DATA ================

  const label = ref(null);

  // ============== COMPUTED ==============

  const ariaAssist = computed(() => {
    const texts = [];

    if (id.value && id.value) {
      texts.push(id.value);
    }

    texts.push('assist');

    return texts.join('-');
  });

  const ariaControls = computed(() => {
    const texts = [];

    if (id.value && id.value) {
      texts.push(id.value);
    }

    texts.push('multiselect-options');

    return texts.join('-');
  });

  const ariaActiveDescendant = computed(() => {
    const texts = [];

    if (id.value && id.value) {
      texts.push(id.value);
    }

    if (pointer.value) {
      texts.push(pointer.value.group ? 'multiselect-group' : 'multiselect-option');
      texts.push(pointer.value.group ? pointer.value.index : pointer.value[valueProp.value]);
    }
      return texts.join('-');
  });



  const ariaPlaceholder = computed(() => {
    return placeholder.value;
  });

  const ariaMultiselectable = computed(() => {
    return mode.value !== 'single';
  });

  const ariaLabel = computed(() => {
    let ariaLabel = '';

    if (mode.value === 'single' && hasSelected.value) {
      ariaLabel += iv.value[labelProp.value];
    }

    if (mode.value === 'multiple' && hasSelected.value) {
      ariaLabel += multipleLabelText.value;
    }

    if (mode.value === 'tags' && hasSelected.value) {
      ariaLabel += iv.value.map(v => v[labelProp.value]).join(', ');
    }

    return ariaLabel;
  });

  const arias = computed(() => {
    const arias = { ...aria.value };
    
    // Need to add manually because focusing
    // the input won't read the selected value
    if (searchable.value) {
      arias['aria-labelledby'] = arias['aria-labelledby']
        ? `${ariaAssist.value} ${arias['aria-labelledby']}`
        : ariaAssist.value;
      
      if (ariaLabel.value && arias['aria-label']) {
        arias['aria-label'] = `${ariaLabel.value}, ${arias['aria-label']}`;
      }
    }

    return arias;
  });

  // =============== METHODS ==============

  const ariaOptionId = (option) => {
    const texts = [];

    if (id.value && id.value) {
      texts.push(id.value);
    }

    texts.push('multiselect-option');

    texts.push(option[valueProp.value]);

    return texts.join('-');
  };

  const ariaGroupId = (option) => {
    const texts = [];

    if (id.value && id.value) {
      texts.push(id.value);
    }

    texts.push('multiselect-group');

    texts.push(option.index);

    return texts.join('-');
  };

  const ariaOptionLabel = (label) => {
    const texts = [];

    texts.push(label);

    return texts.join(' ');
  };

  const ariaGroupLabel = (label) => {
    const texts = [];

    texts.push(label);

    return texts.join(' ');
  };

  const ariaTagLabel = (label) => {
    return `${label} ❎`;
  };

  // =============== HOOKS ================

  onMounted(() => {
    /* istanbul ignore next */
    if (id.value && id.value && document && document.querySelector) {
      const forTag = document.querySelector(`[for="${id.value}"]`);
      label.value = forTag ? forTag.innerText : null;
    }
  });

  return {
    arias,
    ariaLabel,
    ariaAssist,
    ariaControls,
    ariaPlaceholder,
    ariaMultiselectable,
    ariaActiveDescendant,
    ariaOptionId,
    ariaOptionLabel,
    ariaGroupId,
    ariaGroupLabel,
    ariaTagLabel,
  };
}

================================================
File: resources/js/Components/Multiselect/composables/useClasses.js
================================================
import { computed, toRefs } from 'vue';

export default function useClasses(props, context, dependencies) {
    const {
        classes: classes_, disabled, openDirection, showOptions, detatched
    } = toRefs(props);

    // ============ DEPENDENCIES ============

    const isOpen = dependencies.isOpen;
    const isPointed = dependencies.isPointed;
    const isSelected = dependencies.isSelected;
    const isDisabled = dependencies.isDisabled;
    const isActive = dependencies.isActive;
    const canPointGroups = dependencies.canPointGroups;
    const resolving = dependencies.resolving;
    const fo = dependencies.fo;

    const classes = computed(() => ({
        container: 'multiselect',
        containerDisabled: 'is-disabled',
        containerOpen: 'is-open',
        containerOpenTop: 'is-open-top',
        containerActive: 'is-active',
        wrapper: 'multiselect-wrapper',
        singleLabel: 'multiselect-single-label',
        singleLabelText: 'multiselect-single-label-text',
        multipleLabel: 'multiselect-multiple-label',
        search: 'multiselect-search',
        tags: 'multiselect-tags',
        tag: 'multiselect-tag',
        tagDisabled: 'is-disabled',
        tagRemove: 'multiselect-tag-remove',
        tagRemoveIcon: 'multiselect-tag-remove-icon',
        tagsSearchWrapper: 'multiselect-tags-search-wrapper',
        tagsSearch: 'multiselect-tags-search',
        tagsSearchCopy: 'multiselect-tags-search-copy',
        placeholder: 'multiselect-placeholder',
        caret: 'multiselect-caret',
        caretOpen: 'is-open',
        clear: 'multiselect-clear',
        clearIcon: 'multiselect-clear-icon',
        spinner: 'multiselect-spinner',
        inifinite: 'multiselect-inifite',
        inifiniteSpinner: 'multiselect-inifite-spinner',
        dropdown: 'multiselect-dropdown',
        dropdownDetatched: 'detatched',
        dropdownTop: 'is-top',
        dropdownHidden: 'is-hidden',
        options: 'multiselect-options',
        optionsTop: 'is-top',
        group: 'multiselect-group',
        groupLabel: 'multiselect-group-label',
        groupLabelPointable: 'is-pointable',
        groupLabelPointed: 'is-pointed',
        groupLabelSelected: 'is-selected',
        groupLabelDisabled: 'is-disabled',
        groupLabelSelectedPointed: 'is-selected is-pointed',
        groupLabelSelectedDisabled: 'is-selected is-disabled',
        groupOptions: 'multiselect-group-options',
        option: 'multiselect-option',
        optionPointed: 'is-pointed',
        optionSelected: 'is-selected',
        optionDisabled: 'is-disabled',
        optionSelectedPointed: 'is-selected is-pointed',
        optionSelectedDisabled: 'is-selected is-disabled',
        noOptions: 'multiselect-no-options',
        noResults: 'multiselect-no-results',
        fakeInput: 'multiselect-fake-input',
        assist: 'multiselect-assistive-text',
        spacer: 'multiselect-spacer',
        ...classes_.value,
    }));

    // ============== COMPUTED ==============

    const showDropdown = computed(() => {
        return !!(isOpen.value && showOptions.value && (!resolving.value || (resolving.value && fo.value.length)));
    });

    const classList = computed(() => {
        const c = classes.value;

        return {
            container: [c.container]
                .concat(disabled.value ? c.containerDisabled : [])
                .concat(showDropdown.value && openDirection.value === 'top' ? c.containerOpenTop : [])
                .concat(showDropdown.value && openDirection.value !== 'top' ? c.containerOpen : [])
                .concat(isActive.value ? c.containerActive : []),
            wrapper: c.wrapper,
            spacer: c.spacer,
            singleLabel: c.singleLabel,
            singleLabelText: c.singleLabelText,
            multipleLabel: c.multipleLabel,
            search: c.search,
            tags: c.tags,
            tag: [c.tag]
                .concat(disabled.value ? c.tagDisabled : []),
            tagDisabled: c.tagDisabled,
            tagRemove: c.tagRemove,
            tagRemoveIcon: c.tagRemoveIcon,
            tagsSearchWrapper: c.tagsSearchWrapper,
            tagsSearch: c.tagsSearch,
            tagsSearchCopy: c.tagsSearchCopy,
            placeholder: c.placeholder,
            caret: [c.caret]
                .concat(isOpen.value ? c.caretOpen : []),
            clear: c.clear,
            clearIcon: c.clearIcon,
            spinner: c.spinner,
            inifinite: c.inifinite,
            inifiniteSpinner: c.inifiniteSpinner,
            dropdown: [c.dropdown]
                .concat(openDirection.value === 'top' ? c.dropdownTop : [])
                .concat(detatched.value ? c.dropdownDetatched : [])
                .concat(!isOpen.value || !showOptions.value || !showDropdown.value ? c.dropdownHidden : []),
            options: [c.options]
                .concat(openDirection.value === 'top' ? c.optionsTop : []),
            group: c.group,
            groupLabel: (g) => {
                const groupLabel = [c.groupLabel];

                if (isPointed(g)) {
                    groupLabel.push(isSelected(g) ? c.groupLabelSelectedPointed : c.groupLabelPointed);
                } else if (isSelected(g) && canPointGroups.value) {
                    groupLabel.push(isDisabled(g) ? c.groupLabelSelectedDisabled : c.groupLabelSelected);
                } else if (isDisabled(g)) {
                    groupLabel.push(c.groupLabelDisabled);
                }

